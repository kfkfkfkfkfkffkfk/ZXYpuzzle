<!DOCTYPE html>
<html>
<head>
    <title>ZXYpuzzle - Ultimate Smart Edition</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        @keyframes rainbowSwirl { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        @keyframes jellyBounce { 0%, 100% { transform: scale(1); } 25% { transform: scale(1.05) translateY(-5px); } 50% { transform: scale(0.95) translateY(5px); } 75% { transform: scale(1.02) translateY(-2px); } }
        @keyframes bounceUpAndFade { 0% { transform: translateY(0) scale(0.5); opacity: 0; } 20% { transform: translateY(-20px) scale(1.2); opacity: 1; } 50% { transform: translateY(-40px) scale(1); opacity: 1; } 100% { transform: translateY(-80px) scale(0.9); opacity: 0; } }
        @keyframes glowPulse { from { background: rgba(255, 255, 255, 0.5); box-shadow: 0 0 10px rgba(255,255,255,0.3); } to { background: rgba(255, 255, 255, 0.95); box-shadow: 0 0 20px rgba(255,255,255,0.8); } }
        @keyframes pulseRed { from { transform: scale(1); text-shadow: 0 0 10px #FF0055; } to { transform: scale(1.1); text-shadow: 0 0 20px #FF0055, 0 0 30px #FF0055; } }

        body { 
            font-family: 'Segoe UI', Roboto, Helvetica, sans-serif; 
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            background: linear-gradient(45deg, #FF0055, #00DDFF, #FFEA00, #00FF66, #BD00FF);
            background-size: 400% 400%; animation: rainbowSwirl 15s ease infinite;
            color: #333; margin: 0; 
            height: 100dvh; 
            width: 100vw; overflow: hidden; 
            touch-action: none; 
            user-select: none; -webkit-user-select: none;
        }

        /* UI SCREENS */
        #start-screen, #end-screen {
            position: fixed; inset: 0; z-index: 99999;
            background: rgba(10, 15, 30, 0.95); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #fff; text-align: center; padding: 20px; box-sizing: border-box;
        }
        #end-screen { display: none; background: rgba(255,255,255,0.9); color: #333; z-index: 100000; }
        
        #start-screen h1 { font-size: 48px; font-weight: 900; letter-spacing: 4px; margin-bottom: 10px; background: linear-gradient(to right, #00DDFF, #00FF66); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        #start-screen p.subtitle { font-size: 18px; color: #aaa; margin-bottom: 40px; }
        
        .mode-btn { background: rgba(255, 255, 255, 0.05); border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 16px; padding: 25px; margin: 10px; width: 100%; max-width: 350px; cursor: pointer; transition: all 0.2s ease; text-align: left; }
        .mode-btn:hover { background: rgba(255, 255, 255, 0.15); border-color: #00DDFF; transform: translateY(-3px); }
        .mode-btn.rush:hover { border-color: #FF0055; }
        .mode-btn h2 { margin: 0 0 5px 0; font-size: 24px; color: #fff; }
        .mode-btn p { margin: 0; font-size: 14px; color: #bbb; }
        .mode-btn.rush h2 { color: #FF0055; text-shadow: 0 0 10px rgba(255,0,85,0.4); }

        .action-btn { background: #fff; color: #FF0055; border: 3px solid #FF0055; padding: 18px 24px; border-radius: 30px; font-weight: 900; cursor: pointer; margin: 10px; width: 100%; max-width: 280px; font-size: 16px; box-shadow: 0 8px 20px rgba(0,0,0,0.1); transition: all 0.15s; }
        .action-btn:active { transform: scale(0.9); }

        /* GAME BOARD WRAPPER */
        #game-board { 
            position: relative; width: 100vw; height: 100dvh;
            display: none; flex-direction: column; align-items: center; justify-content: flex-start; z-index: 1; 
        }
        .shake { animation: jellyBounce 0.4s cubic-bezier(.25, 1.5, .5, 1) both; }

        #timer-container { width: 600px; max-width: 90vw; display: none; flex-direction: column; align-items: center; margin-top: 10px; }
        #timer-display { font-size: 24px; font-weight: 900; color: #fff; text-shadow: 0 2px 10px rgba(0,0,0,0.5); }
        #timer-bar-bg { width: 100%; height: 10px; background: rgba(0,0,0,0.6); border-radius: 6px; overflow: hidden; border: 2px solid rgba(255,255,255,0.3); }
        #timer-bar-fill { width: 100%; height: 100%; background: #00FF66; }
        .timer-danger { color: #FF0055 !important; animation: pulseRed 0.5s infinite alternate; }
        .bg-danger { background: #FF0055 !important; }

        /* BASE PLAY AREA & DEFAULT STYLES */
        #play-area {
            display: flex; align-items: stretch; justify-content: center;
            width: 100%; flex: 1; min-height: 0; box-sizing: border-box;
        }
        
        #score-display { font-family: 'Comic Sans MS', 'Comic Sans', cursive; font-size: 54px; font-weight: 900; color: #fff; text-shadow: 0 4px 15px rgba(0,0,0,0.4); z-index: 5; text-align: center; }
        .center-column { display: flex; flex-direction: column; align-items: center; justify-content: center; }

        #play-grid { 
            position: relative; display: flex; flex-wrap: wrap; align-content: flex-start;
            background: rgba(0, 0, 0, 0.45); border-radius: 24px; box-sizing: border-box; 
            justify-content: center; border: 2px solid rgba(255, 255, 255, 0.15); backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px); box-shadow: 0 20px 50px rgba(0,0,0,0.4); 
        }
        
        .block-cell { 
            width: calc(10% - 2px); height: calc(10% - 2px); margin: 1px; background: rgba(0, 0, 0, 0.35); 
            border-radius: 50%; pointer-events: none; box-sizing: border-box; transition: all 0.15s ease; border: 1px solid rgba(255, 255, 255, 0.05); 
        }
        .block-cell.active { border: none; z-index: 2; position: relative; }
        .block-cell.snap-hint { animation: glowPulse 0.4s infinite alternate; border: 2px solid #fff; transform: scale(1.05); z-index: 10; }

        .side-dock-wrapper {
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            background: rgba(0,0,0,0.3); box-shadow: inset 0 10px 30px rgba(0,0,0,0.5), 0 10px 20px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.05); box-sizing: border-box; touch-action: pan-y;
        }
        .side-dock-wrapper::-webkit-scrollbar { display: none; }

        .dock-title { color: rgba(255,255,255,0.5); font-weight: 900; text-align: center; }
        #dock, #reserve-dock { display: flex; width: 100%; box-sizing: border-box; }
        
        .shape-wrapper { position: relative; cursor: grab; touch-action: none; transition: transform 0.2s, filter 0.3s, opacity 0.3s; }
        .shape-wrapper:active { filter: brightness(1.2); }
        .shape-layout { display: flex; flex-direction: column; align-items: center; pointer-events: none; }
        .shape-row { display: flex; }
        
        .shape-dot { 
            width: 28px; height: 28px; margin: 1px; border-radius: 50%; 
            border: 1px solid transparent; flex-shrink: 0; box-sizing: border-box;
        }
        .shape-dot.filled { border: 1px solid rgba(255,255,255,0.8); box-shadow: inset 2px 2px 5px rgba(255,255,255,0.8), 0 4px 8px rgba(0,0,0,0.2); pointer-events: auto; }

        .inventory-badge { position: absolute; bottom: 0px; right: 0px; background: #FF0055; color: white; border-radius: 50%; width: 22px; height: 22px; font-size: 14px; font-weight: 900; display: flex; align-items: center; justify-content: center; border: 2px solid #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.5); z-index: 10; pointer-events: none; }
        
        .floating { position: fixed; pointer-events: none; z-index: 9999; transform: scale(1.5) !important; filter: drop-shadow(0 25px 20px rgba(0,0,0,0.4)); opacity: 0.95; transform-origin: top left; }
        .floating-score { position: fixed; z-index: 10000; pointer-events: none; font-family: 'Comic Sans MS', 'Comic Sans', cursive !important; font-weight: bold; color: #fff; text-align: center; text-shadow: 0px 3px 8px rgba(0,0,0,0.4), 0px 0px 8px currentColor; animation: bounceUpAndFade 1.2s forwards; }

        #records { background: #fff; padding: 20px; border-radius: 20px; margin: 15px 0; width: 100%; max-width: 350px; border: 2px solid rgba(0,0,0,0.1); box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
        #records h3 { margin: 0 0 15px 0; font-size: 22px; color: #BD00FF; }
        #records-list { list-style: none; padding: 0; margin: 0; font-size: 18px; font-weight: bold; color: #555; text-align: left; }
        #records-list li { display: flex; justify-content: space-between; border-bottom: 2px dashed rgba(0,0,0,0.1); padding: 10px 0; }

        /* =========================================
           4-WAY RESPONSIVE LAYOUT ENGINE
           ========================================= */

        /* 1. TABLET LANDSCAPE & DESKTOP (Sideways - Default) */
        @media (orientation: landscape) and (min-height: 601px) {
            #timer-container { position: absolute; top: 10px; right: 20px; width: 150px; z-index: 10; }
            #play-area { flex-direction: row; gap: 2vw; padding: 15px 30px; }
            #score-display { margin-bottom: 15px; }
            #play-grid { width: 80vh; height: 80vh; max-width: 650px; max-height: 650px; padding: 12px; }
            .side-dock-wrapper { flex: 1; max-width: 280px; height: 80vh; padding: 20px; border-radius: 24px; overflow-y: auto; }
            .dock-title { font-size: 16px; letter-spacing: 4px; margin-bottom: 20px; border-bottom: 2px dashed rgba(255,255,255,0.1); padding-bottom: 10px; }
            #dock { flex-direction: column; align-items: center; gap: 20px; }
            #reserve-dock { flex-direction: row; flex-wrap: wrap; justify-content: center; gap: 10px; border: 2px dashed rgba(255,255,255,0.2); border-radius: 16px; padding: 10px; background: rgba(0,0,0,0.2); }
            .shape-wrapper { padding: 10px; }
            .shape-wrapper:active { transform: scale(1.15); }
        }

        /* 2. PHONE LANDSCAPE (Sideways) */
        @media (orientation: landscape) and (max-height: 600px) {
            #score-display { font-size: 32px; position: absolute; top: 5px; left: 15px; z-index: 10; margin: 0; }
            #timer-container { position: absolute; bottom: 10px; left: 15px; width: 120px; margin: 0; z-index: 10; }
            #play-area { flex-direction: row; justify-content: space-between; gap: 1vw; padding: 5px 10px; }
            .center-column { flex: 0 0 auto; justify-content: center; height: 100vh; }
            #play-grid { width: 90vh; height: 90vh; padding: 6px; border-radius: 12px; }
            .side-dock-wrapper { flex: 1; max-width: 25vw; height: 95vh; padding: 5px; border-radius: 16px; overflow-y: auto; }
            .dock-title { font-size: 11px; margin-bottom: 5px; padding-bottom: 2px; letter-spacing: 2px; border-bottom: 1px dashed rgba(255,255,255,0.2); }
            #dock { flex-direction: column; align-items: center; gap: 5px; }
            #reserve-dock { flex-direction: column; align-items: center; gap: 5px; }
            .shape-wrapper { padding: 2px; transform: scale(0.65); transform-origin: center; }
            .shape-wrapper:active { transform: scale(0.8); }
        }

        /* 3. TABLET PORTRAIT (iPad Upright) */
        @media (orientation: portrait) and (min-width: 768px) {
            #score-display { font-size: 64px; margin-top: 20px; margin-bottom: 15px; }
            #play-area { flex-direction: row; flex-wrap: wrap; align-items: flex-start; justify-content: center; gap: 20px; padding: 20px; overflow-y: auto; }
            .center-column { order: 1; width: 100%; flex: 0 0 auto; }
            #play-grid { width: 80vw; height: 80vw; max-width: 650px; max-height: 650px; padding: 12px; margin: 0 auto; }
            .side-dock-wrapper { padding: 20px; border-radius: 24px; }
            .side-dock-wrapper.active-area { order: 2; width: calc(50% - 10px); max-width: 350px; min-height: 250px; flex-direction: column; }
            .side-dock-wrapper.reserve-area { order: 3; width: calc(50% - 10px); max-width: 350px; min-height: 250px; flex-direction: column; }
            .dock-title { font-size: 16px; letter-spacing: 4px; margin-bottom: 15px; border-bottom: 2px dashed rgba(255,255,255,0.1); padding-bottom: 10px; width: 100%; }
            #dock, #reserve-dock { flex-direction: row; flex-wrap: wrap; justify-content: center; gap: 15px; }
            .shape-wrapper { padding: 10px; }
            .shape-wrapper:active { transform: scale(1.15); }
        }

        /* 4. PHONE PORTRAIT (Upright) */
        @media (orientation: portrait) and (max-width: 767px) {
            #score-display { font-size: 46px; margin-bottom: 10px; margin-top: 15px; }
            #play-area { flex-direction: column; flex-wrap: nowrap; align-items: center; gap: 15px; padding: 10px; overflow-y: auto; overflow-x: hidden; }
            .center-column { order: 1; width: 100%; flex: 0 0 auto; }
            #play-grid { width: 94vw; height: 94vw; max-width: 450px; max-height: 450px; padding: 8px; border-radius: 16px; margin: 0 auto; }
            
            /* Horizontal Shelves for Mobile */
            .side-dock-wrapper { flex: 0 0 auto; width: 94vw; max-width: 450px; padding: 12px; border-radius: 16px; justify-content: flex-start; }
            .side-dock-wrapper.active-area { order: 2; min-height: 110px; }
            .side-dock-wrapper.reserve-area { order: 3; min-height: 110px; margin-bottom: 20px; }
            
            .dock-title { font-size: 12px; margin-bottom: 5px; letter-spacing: 3px; border-bottom: none; text-align: left; margin-left: 5px; color: rgba(255,255,255,0.8); }
            #dock, #reserve-dock { flex-direction: row; flex-wrap: nowrap; overflow-x: auto; overflow-y: hidden; justify-content: flex-start; align-items: center; gap: 15px; padding-bottom: 5px; width: 100%; }
            #dock::-webkit-scrollbar, #reserve-dock::-webkit-scrollbar { display: none; }
            
            .shape-wrapper { padding: 5px; flex-shrink: 0; transform: scale(0.9); }
            .shape-wrapper:active { transform: scale(1); }
        }
    </style>
</head>
<body>

<div id="start-screen">
    <h1>ZXYpuzzle</h1>
    <p class="subtitle">Ultimate Smart Edition</p>
    <div class="mode-btn classic" onclick="startGame('classic')">
        <h2>CLASSIC MODE</h2><p>Take your time. Build massive combos.</p>
    </div>
    <div class="mode-btn rush" onclick="startGame('rush')">
        <h2>RUSH MODE</h2><p>10 seconds per move. Act fast!</p>
    </div>
</div>

<div id="game-board">
    <div id="timer-container"><div id="timer-display">10.0s</div><div id="timer-bar-bg"><div id="timer-bar-fill"></div></div></div>
    
    <div id="play-area">
        <div class="side-dock-wrapper reserve-area">
            <div class="dock-title">INVENTORY</div>
            <div id="reserve-dock"></div>
        </div>

        <div class="center-column">
            <div id="score-display">0</div>
            <div id="play-grid"></div>
        </div>
        
        <div class="side-dock-wrapper active-area">
            <div class="dock-title">ACTIVE PIECES</div>
            <div id="dock"></div>
        </div>
    </div>
</div>

<div id="end-screen">
    <h1 style="color:#FF0055; font-size: 50px; margin-bottom: 5px;">OH NO!</h1>
    <p id="death-reason" style="color:#FF8800; font-weight:bold; font-size: 18px; margin: 0;"></p>
    <p style="margin-top: 10px; font-size: 20px; font-weight: bold;">SCORE: <br><span id="final-tally" style="color: #BD00FF; font-size: 42px;">0</span></p>
    <div id="records"><h3>TOP SCORES</h3><ul id="records-list"></ul></div>
    <button id="btn-continue" class="action-btn" onclick="useContinue()" style="background:#00FF66; color:#333; border-color:#00FF66;">CONTINUE (3 LEFT)</button>
    <button class="action-btn" onclick="startGame(currentMode)" style="background:#FFEA00; color:#333; border-color:#FFEA00;">START OVER</button>
    <button class="action-btn" onclick="location.reload()" style="background:#00DDFF; color:#fff; border-color:#00DDFF;">MAIN MENU</button>
</div>

<script>
    document.addEventListener('touchmove', function(e) {
        if (e.target.closest('.side-dock-wrapper')) return; 
        if (e.target.closest('body')) e.preventDefault(); 
    }, { passive: false });

    function triggerHaptic(pattern) {
        if (navigator.vibrate) navigator.vibrate(pattern);
    }

    const playGrid = document.getElementById("play-grid");
    const dockEl = document.getElementById("dock");
    const reserveDock = document.getElementById("reserve-dock");
    const scoreText = document.getElementById("score-display");
    const timerContainer = document.getElementById("timer-container");
    const timerDisplay = document.getElementById("timer-display");
    const timerBarFill = document.getElementById("timer-bar-fill");
    const gameBoard = document.getElementById("game-board");
    
    const snapSound = new Audio('switch-snap.mp3');
    
    let boardState = Array(100).fill(null);
    let currentScore = 0;
    let activeShapes = []; 
    let reserveInventory = []; 
    let activePopups = 0; 
    let continuesLeft = 3; 
    let currentMode = 'classic';
    let rushTimer; let timeRemaining = 10.0; let gameActive = false; let lastTime = 0;
    let bestScores = [0, 0, 0, 0, 0];

    const candyColors = ["#FF0055", "#FF8800", "#FFEA00", "#00FF66", "#00DDFF", "#BD00FF", "#FF00AA"];
    
    for (let i = 0; i < 100; i++) {
        const cell = document.createElement("div");
        cell.className = "block-cell";
        playGrid.appendChild(cell);
    }

    const layouts = [
        [[0,0]], [[0,0], [0,1]], [[0,0], [1,0]], 
        [[0,0], [0,1], [1,0], [1,1]], [[0,0], [0,1], [0,2], [0,3]], 
        [[0,0], [1,0], [2,0], [3,0]], [[0,0], [0,1], [0,2], [1,1]], 
        [[0,0], [1,0], [2,0], [2,1]], [[0,1], [1,1], [2,0], [2,1]], 
        [[0,0], [0,1], [0,2], [1,0], [1,1], [1,2], [2,0], [2,1], [2,2]], 
        [[0,0], [1,1], [2,2]], [[0,0], [0,1], [0,2]]
    ];

    window.startGame = function(mode) {
        triggerHaptic(30);
        currentMode = mode; continuesLeft = 3; gameActive = true;
        document.getElementById("start-screen").style.display = "none";
        document.getElementById("end-screen").style.display = "none";
        document.getElementById("game-board").style.display = "flex";
        timerContainer.style.display = currentMode === 'rush' ? "flex" : "none";
        wipeBoardClean();
        fillDock();
    };

    function gameLoop(timestamp) {
        if (!gameActive || currentMode !== 'rush') return;
        if (!lastTime) lastTime = timestamp;
        timeRemaining -= (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        if (timeRemaining <= 0) { timeRemaining = 0; triggerGameOver("OUT OF TIME! â°"); }
        else {
            timerDisplay.innerText = timeRemaining.toFixed(1) + "s";
            timerBarFill.style.width = (timeRemaining * 10) + "%";
            if (timeRemaining <= 3) { timerDisplay.classList.add("timer-danger"); timerBarFill.classList.add("bg-danger"); } 
            else { timerDisplay.classList.remove("timer-danger"); timerBarFill.classList.remove("bg-danger"); }
            rushTimer = requestAnimationFrame(gameLoop);
        }
    }

    function spawnFloatingText(text, totalLines, targetEl) {
        const popup = document.createElement("div");
        popup.className = "floating-score";
        popup.innerHTML = text; 
        
        let color = "#00FF66"; 
        let size = "36px";
        
        if (totalLines === 1) { color = "#00FF66"; size = "36px"; }
        else if (totalLines === 2) { color = "#00DDFF"; size = "42px"; }
        else if (totalLines === 3) { color = "#BD00FF"; size = "48px"; }
        else if (totalLines === 4) { color = "#FFEA00"; size = "56px"; popup.style.zIndex = "10001"; }
        else if (totalLines >= 5) { color = "#FF0055"; size = "64px"; popup.style.zIndex = "10001"; }

        popup.style.color = color;
        popup.style.fontSize = size;
        
        const rect = targetEl.getBoundingClientRect();
        popup.style.left = (rect.left + rect.width / 2 - 60) + "px";
        popup.style.top = (rect.top + rect.height / 2 - (activePopups * 40)) + "px";
        
        document.body.appendChild(popup);
        activePopups++; setTimeout(() => activePopups--, 1200); setTimeout(() => popup.remove(), 1200);
    }

    function renderReserve(bounceSignatures = []) {
        reserveDock.innerHTML = "";
        reserveInventory.forEach(item => {
            buildDraggableShape(item, reserveDock);
            if (bounceSignatures.includes(item.signature) && item.element) {
                item.element.classList.add("shake");
            }
        });
    }

    function refreshActiveDock() {
        dockEl.innerHTML = "";
        activeShapes.forEach((s) => {
            if (s !== null) buildDraggableShape(s, dockEl);
        });
        verifyMovesLeft();
    }

    function fillDock() {
        activeShapes = []; 
        let playablePool = layouts.filter(layout => findAllValidSpots(layout).length > 0);

        for (let i = 0; i < 3; i++) {
            let layout;
            if (i === 0 && playablePool.length > 0) {
                layout = playablePool[Math.floor(Math.random() * playablePool.length)];
            } else {
                layout = layouts[Math.floor(Math.random() * layouts.length)];
            }
            const shapeObj = {layout: layout, color: candyColors[Math.floor(Math.random()*candyColors.length)], element: null, isReserve: false};
            activeShapes.push(shapeObj); 
        }
        refreshActiveDock();
    }

    function findSmartestSpot(shapeObj) {
        let bestSpot = null;
        let maxScore = -Infinity;
        const validSpots = findAllValidSpots(shapeObj.layout);

        for (let spot of validSpots) {
            let score = 0;
            shapeObj.layout.forEach(pt => { boardState[(spot.r+pt[0])*10 + (spot.c+pt[1])] = 'temp'; });
            
            let rowsCleared = 0, colsCleared = 0, diagsCleared = 0;
            for(let r=0; r<10; r++) if ([...Array(10)].every((_,c) => boardState[r*10+c])) rowsCleared++;
            for(let c=0; c<10; c++) if ([...Array(10)].every((_,r) => boardState[r*10+c])) colsCleared++;
            if ([...Array(10)].every((_,i) => boardState[i*10+i])) diagsCleared++;
            if ([...Array(10)].every((_,i) => boardState[i*10+(9-i)])) diagsCleared++;
            
            let totalLines = rowsCleared + colsCleared + diagsCleared;
            score += totalLines * 10000;
            if (totalLines > 1) score += Math.pow(totalLines, 2) * 2000; 

            shapeObj.layout.forEach(pt => {
                let r = spot.r + pt[0]; let c = spot.c + pt[1];
                if (r === 0 || (boardState[(r-1)*10+c] && boardState[(r-1)*10+c] !== 'temp')) score += 20;
                if (r === 9 || (boardState[(r+1)*10+c] && boardState[(r+1)*10+c] !== 'temp')) score += 20;
                if (c === 0 || (boardState[r*10+(c-1)] && boardState[r*10+(c-1)] !== 'temp')) score += 20;
                if (c === 9 || (boardState[r*10+(c+1)] && boardState[r*10+(c+1)] !== 'temp')) score += 20;
            });

            if (totalLines === 0) {
                let centerDistR = Math.abs(spot.r + shapeObj.layout[0][0] - 4.5);
                let centerDistC = Math.abs(spot.c + shapeObj.layout[0][1] - 4.5);
                score += (centerDistR + centerDistC) * 5; 
            }

            shapeObj.layout.forEach(pt => { boardState[(spot.r+pt[0])*10 + (spot.c+pt[1])] = null; });

            if (score > maxScore) { maxScore = score; bestSpot = spot; }
        }
        return bestSpot;
    }

    function consumeShapeAndCheckState(shapeObj, wrap) {
        if (shapeObj.isReserve) {
            let invItem = reserveInventory.find(i => i.signature === shapeObj.signature);
            if (invItem) {
                invItem.count--;
                if (invItem.count <= 0) {
                    reserveInventory = reserveInventory.filter(i => i.signature !== shapeObj.signature);
                }
            }
            renderReserve();
        } else {
            let idx = activeShapes.indexOf(shapeObj); 
            if (idx > -1) {
                let playablePool = layouts.filter(layout => findAllValidSpots(layout).length > 0);
                let layout = playablePool.length > 0 
                    ? playablePool[Math.floor(Math.random() * playablePool.length)] 
                    : layouts[Math.floor(Math.random() * layouts.length)];
                
                activeShapes[idx] = {layout: layout, color: candyColors[Math.floor(Math.random()*candyColors.length)], element: null, isReserve: false};
            }
            refreshActiveDock();
        }
        
        verifyMovesLeft();
        if (currentMode === 'rush') { timeRemaining = 10.0; lastTime = 0; rushTimer = requestAnimationFrame(gameLoop); }
    }

    function getBestDropPos(shapeObj, clientX, clientY, isDrop) {
        const hoverPos = locateGridIndex(clientX, clientY);
        const validSpots = findAllValidSpots(shapeObj.layout);
        if (validSpots.length === 0) return null;

        if (hoverPos !== null) {
            const r = Math.floor(hoverPos/10) - shapeObj.dragOffsetR;
            const c = (hoverPos%10) - shapeObj.dragOffsetC;
            if (hasRoom(shapeObj.layout, r, c)) return {r, c};
        }

        if (isDrop || validSpots.length === 1) {
            let minD = Infinity; let bestSpot = null;
            const gridRect = playGrid.getBoundingClientRect();
            const cellW = gridRect.width / 10;
            
            for (let spot of validSpots) {
                let spotX = gridRect.left + (spot.c * cellW) + (shapeObj.layout[0][1] * cellW);
                let spotY = gridRect.top + (spot.r * cellW) + (shapeObj.layout[0][0] * cellW);
                let dist = Math.hypot(clientX - spotX, clientY - spotY);
                if (dist < minD) { minD = dist; bestSpot = spot; }
            }
            if (bestSpot && (minD < gridRect.width * 1.5)) return bestSpot; 
        }
        return null;
    }

    function buildDraggableShape(shapeObj, containerEl) {
        const wrap = document.createElement("div"); wrap.className = "shape-wrapper";
        shapeObj.element = wrap;
        
        const gridBox = document.createElement("div"); gridBox.className = "shape-layout";
        let rMax = Math.max(...shapeObj.layout.map(p=>p[0])), cMax = Math.max(...shapeObj.layout.map(p=>p[1]));

        let isGiant = rMax > 4 || cMax > 4;
        let dSize = 28; 

        for (let r=0; r<=rMax; r++) {
            const rDiv = document.createElement("div"); rDiv.className = "shape-row";
            for (let c=0; c<=cMax; c++) {
                const dot = document.createElement("div");
                let isOn = shapeObj.layout.some(pt => pt[0]===r && pt[1]===c);
                dot.className = isOn ? "shape-dot filled" : "shape-dot blank";
                
                if(isOn) { dot.style.background = shapeObj.color; dot.dataset.r = r; dot.dataset.c = c; }
                rDiv.appendChild(dot);
            }
            gridBox.appendChild(rDiv);
        }

        if (isGiant) {
            gridBox.style.transform = "scale(0.35)";
            gridBox.style.transformOrigin = "center";
            wrap.style.width = ((cMax+1) * 30 * 0.35) + "px";
            wrap.style.height = ((rMax+1) * 30 * 0.35) + "px";
            wrap.style.display = "flex"; wrap.style.alignItems = "center"; wrap.style.justifyContent = "center";
        }

        wrap.appendChild(gridBox);

        if (shapeObj.count && shapeObj.count > 1) {
            let badge = document.createElement("div");
            badge.className = "inventory-badge";
            badge.innerText = shapeObj.count;
            wrap.appendChild(badge);
        }

        containerEl.appendChild(wrap);

        wrap.onpointerdown = (e) => {
            if (!gameActive || wrap.dataset.dragging === "true") return;
            wrap.dataset.dragging = "true"; 
            triggerHaptic(15); 

            e.preventDefault(); 
            let startX = e.clientX; let startY = e.clientY; let startTime = Date.now(); 

            let grabR = shapeObj.layout[0][0], grabC = shapeObj.layout[0][1];
            if (e.target.classList.contains('filled')) { grabR = parseInt(e.target.dataset.r); grabC = parseInt(e.target.dataset.c); }
            shapeObj.dragOffsetR = grabR; shapeObj.dragOffsetC = grabC; 

            const ghost = wrap.cloneNode(true); ghost.classList.add("floating");
            if (isGiant) {
                ghost.querySelector('.shape-layout').style.transform = "scale(1)";
                ghost.style.width = "auto"; ghost.style.height = "auto";
            }
            
            let ghostBadge = ghost.querySelector('.inventory-badge');
            if (ghostBadge) ghostBadge.style.display = 'none';

            document.body.appendChild(ghost); wrap.style.opacity = "0.05";
            
            const scale = 1.5; 
            const originX = (10 + grabC * dSize + dSize/2) * scale;
            const originY = (10 + grabR * dSize + dSize/2) * scale;

            const move = (ev) => {
                let newX = ev.clientX - originX; let newY = ev.clientY - originY;
                newX = Math.max(0, Math.min(newX, window.innerWidth - ghost.offsetWidth));
                newY = Math.max(0, Math.min(newY, window.innerHeight - ghost.offsetHeight));
                ghost.style.left = newX + "px"; ghost.style.top = newY + "px"; 
                
                wipeHints();
                const targetPos = getBestDropPos(shapeObj, ev.clientX, ev.clientY, false);
                if (targetPos) drawHint(shapeObj.layout, targetPos.r, targetPos.c);
            };

            const drop = (ev) => {
                wrap.dataset.dragging = "false";
                window.removeEventListener("pointermove", move); window.removeEventListener("pointerup", drop);
                
                let dx = ev.clientX - startX; let dy = ev.clientY - startY;
                let isTap = Math.abs(dx) < 10 && Math.abs(dy) < 10 && (Date.now() - startTime) < 300;

                if (isTap) {
                    let bestSpot = findSmartestSpot(shapeObj);
                    if (bestSpot) {
                        lockInShape(shapeObj, bestSpot.r, bestSpot.c);
                        consumeShapeAndCheckState(shapeObj, wrap);
                    } else { wrap.style.opacity = "1"; }
                } else {
                    const targetPos = getBestDropPos(shapeObj, ev.clientX, ev.clientY, true);
                    if (targetPos) { 
                        lockInShape(shapeObj, targetPos.r, targetPos.c); 
                        consumeShapeAndCheckState(shapeObj, wrap);
                    } else { wrap.style.opacity = "1"; }
                }
                
                wipeHints(); ghost.remove(); 
                if (!shapeObj.isReserve && activeShapes.some(s => s !== null)) verifyMovesLeft(); 
            };
            window.addEventListener("pointermove", move); window.addEventListener("pointerup", drop);
        };
    }

    function locateGridIndex(x, y) {
        const tiles = playGrid.children;
        for (let i = 0; i < 100; i++) {
            if (!tiles[i]) continue;
            const b = tiles[i].getBoundingClientRect();
            if (x >= b.left && x <= b.right && y >= b.top && y <= b.bottom) return i; 
        }
        return null;
    }

    function findAllValidSpots(layout) {
        let spots = [];
        for (let r=0; r<10; r++) for (let c=0; c<10; c++) if (hasRoom(layout, r, c)) spots.push({r, c});
        return spots;
    }

    function hasRoom(layout, startR, startC) {
        return layout.every(pt => { let r = startR+pt[0], c = startC+pt[1]; return r>=0 && r<10 && c>=0 && c<10 && boardState[r*10+c] === null; });
    }

    function lockInShape(shapeObj, startR, startC) {
        snapSound.currentTime = 0; 
        snapSound.play().catch(e => console.log("User interaction required for audio."));
        triggerHaptic(50); 

        shapeObj.layout.forEach(pt => {
            let i = (startR+pt[0])*10 + (startC+pt[1]);
            boardState[i] = shapeObj.color; 
            playGrid.children[i].classList.add("active");
            playGrid.children[i].style.background = shapeObj.color;
            playGrid.children[i].style.boxShadow = `inset 2px 2px 8px rgba(255,255,255,0.7), inset -2px -2px 8px rgba(0,0,0,0.1), 0 2px 5px rgba(0,0,0,0.1)`;
        });
        currentScore += shapeObj.layout.length * 10; scoreText.innerText = currentScore;
        checkClears();
    }

    let recentlyUpdatedSignatures = [];

    function addRewardToInventory(layoutArray) {
        let signature = JSON.stringify(layoutArray);
        let existingItem = reserveInventory.find(item => item.signature === signature);
        
        if (existingItem) {
            existingItem.count++;
        } else {
            reserveInventory.push({
                layout: layoutArray,
                color: candyColors[Math.floor(Math.random()*candyColors.length)],
                isReserve: true,
                signature: signature,
                count: 1
            });
        }
        recentlyUpdatedSignatures.push(signature);
    }

    function checkClears() {
        let fullRows = [], fullCols = [], diags = [];
        for(let r=0; r<10; r++) { if ([...Array(10)].every((_,c) => boardState[r*10+c])) fullRows.push(r); }
        for(let c=0; c<10; c++) { if ([...Array(10)].every((_,r) => boardState[r*10+c])) fullCols.push(c); }
        if ([...Array(10)].every((_,i) => boardState[i*10+i])) diags.push('diag1');
        if ([...Array(10)].every((_,i) => boardState[i*10+(9-i)])) diags.push('diag2');

        const totalLines = fullRows.length + fullCols.length + diags.length;
        
        if (totalLines > 0) {
            recentlyUpdatedSignatures = []; 
            
            triggerHaptic([50, 50, 50]); 
            gameBoard.classList.remove("shake"); void gameBoard.offsetWidth; gameBoard.classList.add("shake");
            let pts = totalLines * 1000; currentScore += pts; scoreText.innerText = currentScore;
            
            let word = "";
            if (totalLines === 1) word = "Nice!";
            else if (totalLines === 2) word = "Awesome!";
            else if (totalLines === 3) word = "Epic!";
            else if (totalLines === 4) word = "Legendary!";
            else if (totalLines >= 5 && totalLines < 10) word = "Unreal!";
            else if (totalLines >= 10) word = "Unreal.+";

            spawnFloatingText(word, totalLines, playGrid);

            let toClear = new Set();
            fullRows.forEach(r => { for(let c=0; c<10; c++) toClear.add(r*10+c); });
            fullCols.forEach(c => { for(let r=0; r<10; r++) toClear.add(r*10+c); });
            if (diags.includes('diag1')) [...Array(10)].forEach((_,i) => toClear.add(i*10+i));
            if (diags.includes('diag2')) [...Array(10)].forEach((_,i) => toClear.add(i*10+(9-i)));

            if (toClear.size > 0) {
                let giantLayout = [];
                let minR = 10, minC = 10;
                
                toClear.forEach(idx => {
                    let r = Math.floor(idx / 10);
                    let c = idx % 10;
                    if (r < minR) minR = r;
                    if (c < minC) minC = c;
                });
                
                toClear.forEach(idx => {
                    let r = Math.floor(idx / 10);
                    let c = idx % 10;
                    giantLayout.push([r - minR, c - minC]);
                });

                addRewardToInventory(giantLayout);
            }
            
            renderReserve(recentlyUpdatedSignatures);

            toClear.forEach(idx => {
                boardState[idx] = null;
                if(playGrid.children[idx]) {
                    playGrid.children[idx].classList.remove("active");
                    playGrid.children[idx].style.background = "rgba(0, 0, 0, 0.35)";
                    playGrid.children[idx].style.boxShadow = "none";
                }
            });
        }
    }

    function wipeHints() {
        for(let i=0; i<100; i++) {
            if (playGrid.children[i]) playGrid.children[i].classList.remove("snap-hint");
        }
    }

    function drawHint(layout, startR, startC) {
        layout.forEach(pt => {
            let idx = (startR+pt[0])*10 + (startC+pt[1]);
            if(idx >= 0 && idx < 100) {
                if (playGrid.children[idx]) playGrid.children[idx].classList.add("snap-hint");
            }
        });
    }

    function wipeBoardClean() {
        boardState.fill(null);
        currentScore = 0;
        scoreText.innerText = "0";
        for (let i = 0; i < 100; i++) {
            if (playGrid.children[i]) {
                playGrid.children[i].classList.remove("active");
                playGrid.children[i].style.background = "rgba(0, 0, 0, 0.35)";
                playGrid.children[i].style.boxShadow = "none";
            }
        }
        activeShapes = [];
        reserveInventory = []; 
        renderReserve();
        dockEl.innerHTML = "";
        wipeHints();
    }

    function verifyMovesLeft() {
        let canMove = false;
        
        for (let shape of activeShapes) {
            if (shape && findAllValidSpots(shape.layout).length > 0) { canMove = true; break; }
        }
        
        for (let item of reserveInventory) {
            if (item && findAllValidSpots(item.layout).length > 0) { canMove = true; break; }
        }

        if (!canMove && activeShapes.some(s => s !== null)) {
            setTimeout(() => triggerGameOver("NO MOVES LEFT!"), 300);
        }
    }

    function triggerGameOver(reason) {
        triggerHaptic([100, 50, 100, 50, 200]); 
        gameActive = false;
        cancelAnimationFrame(rushTimer);
        document.getElementById("death-reason").innerText = reason;
        document.getElementById("final-tally").innerText = currentScore;
        
        bestScores.push(currentScore);
        bestScores.sort((a,b)=>b-a);
        bestScores = bestScores.slice(0,5);
        const list = document.getElementById("records-list");
        list.innerHTML = "";
        bestScores.forEach((s, i) => {
            if(s > 0) list.innerHTML += `<li><span>#${i+1}</span> <span>${s}</span></li>`;
        });

        const btnContinue = document.getElementById("btn-continue");
        if (continuesLeft > 0) {
            btnContinue.style.display = "inline-block";
            btnContinue.innerText = `CONTINUE (${continuesLeft} LEFT)`;
        } else {
            btnContinue.style.display = "none";
        }

        document.getElementById("game-board").style.display = "none";
        document.getElementById("end-screen").style.display = "flex";
    }

    window.useContinue = function() {
        triggerHaptic(30);
        if (continuesLeft <= 0) return;
        continuesLeft--;
        document.getElementById("end-screen").style.display = "none";
        document.getElementById("game-board").style.display = "flex";
        gameActive = true;
        
        fillDock(); 
        
        if (currentMode === 'rush') {
            timeRemaining = 10.0;
            lastTime = 0;
            rushTimer = requestAnimationFrame(gameLoop);
        }
    };
</script>
</body>
</html>
