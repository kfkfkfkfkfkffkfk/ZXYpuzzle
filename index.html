<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Puzzle Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2c3e50;
            color: white;
            margin-top: 50px;
        }

        /* --- Board & Centered Score --- */
        #game-container {
            position: relative;
            background-color: #34495e;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, 40px);
            grid-template-rows: repeat(8, 40px);
            gap: 2px;
            background-color: #2c3e50;
        }

        .cell {
            width: 40px;
            height: 40px;
            background-color: #7f8c8d;
            border-radius: 4px;
        }

        .cell.filled {
            background-color: #3498db;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
        }

        #score-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 80px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.3); /* Semi-transparent */
            pointer-events: none; /* So you can drag blocks through it */
            z-index: 5;
            margin: 0;
        }

        /* --- Hype Popups --- */
        #popup-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            font-weight: bold;
            color: #f1c40f;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: all 0.1s;
        }

        .animate-popup {
            animation: popAndFade 1.2s ease-out forwards;
        }

        @keyframes popAndFade {
            0% { opacity: 0; transform: translate(-50%, -20%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -60%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -80%) scale(0.8); }
        }

        /* --- Reserve Blocks --- */
        #reserve-tray {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
            height: 100px;
            align-items: center;
        }

        .reserve-shape {
            display: grid;
            gap: 2px;
            cursor: grab;
        }

        .reserve-shape:active {
            cursor: grabbing;
        }

        .shape-block {
            width: 30px;
            height: 30px;
            background-color: #e74c3c;
            border-radius: 4px;
        }
        
        .empty-block {
            width: 30px;
            height: 30px;
            background-color: transparent;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="score-display">0</div>
        <div id="popup-display"></div>
        <div id="board"></div>
    </div>

    <div id="reserve-tray"></div>

    <script>
        const BOARD_SIZE = 8;
        let score = 0;
        let grid = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(0));
        let draggedShape = null;
        let draggedShapeIndex = -1;
        let reserveShapes = [];

        const hypeWords = ["Nice!", "Awesome!", "Epic!", "Superb!", "Wow!", "Boom!"];

        // Define a few simple shapes (1 means block, 0 means empty space)
        const SHAPES = [
            [[1]], // 1x1
            [[1, 1]], // 2x1 horizontal
            [[1], [1]], // 1x2 vertical
            [[1, 1], [1, 1]], // 2x2 square
            [[1, 1, 1]], // 3x1 horizontal
            [[1], [1], [1]], // 1x3 vertical
            [[1, 1], [1, 0]] // L-shape small
        ];

        const boardEl = document.getElementById('board');
        const scoreEl = document.getElementById('score-display');
        const popupEl = document.getElementById('popup-display');
        const reserveTrayEl = document.getElementById('reserve-tray');

        // 1. Initialize Board
        function createBoard() {
            boardEl.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    // Drag and drop event listeners for the board cells
                    cell.addEventListener('dragover', (e) => e.preventDefault());
                    cell.addEventListener('drop', handleDrop);
                    
                    boardEl.appendChild(cell);
                }
            }
        }

        // 2. Generate Reserve Blocks
        function refillReserve() {
            reserveTrayEl.innerHTML = '';
            reserveShapes = [];
            for (let i = 0; i < 3; i++) {
                const randomShape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                reserveShapes.push(randomShape);
                renderReserveShape(randomShape, i);
            }
        }

        function renderReserveShape(shape, index) {
            if (!shape) return; // If shape was used
            
            const shapeContainer = document.createElement('div');
            shapeContainer.classList.add('reserve-shape');
            shapeContainer.draggable = true;
            shapeContainer.style.gridTemplateColumns = `repeat(${shape[0].length}, 30px)`;
            
            shapeContainer.addEventListener('dragstart', (e) => {
                draggedShape = shape;
                draggedShapeIndex = index;
            });

            shape.forEach(row => {
                row.forEach(val => {
                    const block = document.createElement('div');
                    block.classList.add(val ? 'shape-block' : 'empty-block');
                    shapeContainer.appendChild(block);
                });
            });

            reserveTrayEl.appendChild(shapeContainer);
        }

        // 3. Handle Dropping Blocks on the Board
        function handleDrop(e) {
            e.preventDefault();
            if (!draggedShape) return;

            const targetRow = parseInt(e.target.dataset.row);
            const targetCol = parseInt(e.target.dataset.col);

            // Check if shape fits
            if (canPlaceShape(draggedShape, targetRow, targetCol)) {
                placeShape(draggedShape, targetRow, targetCol);
                
                // Remove the shape from reserve
                reserveShapes[draggedShapeIndex] = null;
                renderTrayState();

                // Check for clears and update score
                checkClears();

                // Refill tray if empty
                if (reserveShapes.every(s => s === null)) {
                    refillReserve();
                }
            }
            draggedShape = null;
        }

        function canPlaceShape(shape, startRow, startCol) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c] === 1) {
                        const boardRow = startRow + r;
                        const boardCol = startCol + c;
                        // Out of bounds or already filled
                        if (boardRow >= BOARD_SIZE || boardCol >= BOARD_SIZE || grid[boardRow][boardCol] === 1) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function placeShape(shape, startRow, startCol) {
            let blocksPlaced = 0;
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c] === 1) {
                        grid[startRow + r][startCol + c] = 1;
                        blocksPlaced++;
                        // Update visual cell
                        const cellIndex = (startRow + r) * BOARD_SIZE + (startCol + c);
                        boardEl.children[cellIndex].classList.add('filled');
                    }
                }
            }
            // Add points just for placing blocks
            score += blocksPlaced;
            scoreEl.innerText = score;
        }

        function renderTrayState() {
            reserveTrayEl.innerHTML = '';
            reserveShapes.forEach((shape, index) => {
                if (shape) {
                    renderReserveShape(shape, index);
                } else {
                    // Empty placeholder space to keep layout nice
                    const placeholder = document.createElement('div');
                    placeholder.style.width = '60px'; 
                    reserveTrayEl.appendChild(placeholder);
                }
            });
        }

        // 4. Line Clearing Logic & Hype Popups
        function checkClears() {
            let rowsToClear = [];
            let colsToClear = [];

            // Check rows
            for (let r = 0; r < BOARD_SIZE; r++) {
                if (grid[r].every(val => val === 1)) rowsToClear.push(r);
            }

            // Check columns
            for (let c = 0; c < BOARD_SIZE; c++) {
                let isFull = true;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    if (grid[r][c] === 0) {
                        isFull = false;
                        break;
                    }
                }
                if (isFull) colsToClear.push(c);
            }

            const totalClears = rowsToClear.length + colsToClear.length;

            if (totalClears > 0) {
                // Remove blocks from the grid
                rowsToClear.forEach(r => {
                    for (let c = 0; c < BOARD_SIZE; c++) { grid[r][c] = 0; }
                });
                colsToClear.forEach(c => {
                    for (let r = 0; r < BOARD_SIZE; r++) { grid[r][c] = 0; }
                });

                // Update visual board
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        const cellIndex = r * BOARD_SIZE + c;
                        if (grid[r][c] === 0) {
                            boardEl.children[cellIndex].classList.remove('filled');
                        }
                    }
                }

                // Add score (10 points per line cleared)
                score += totalClears * 10;
                scoreEl.innerText = score;

                // Trigger Hype Popup!
                triggerHypePopup();
            }
        }

        function triggerHypePopup() {
            // Pick random word
            const randomWord = hypeWords[Math.floor(Math.random() * hypeWords.length)];
            popupEl.innerText = randomWord;
            
            // Reset animation
            popupEl.classList.remove('animate-popup');
            void popupEl.offsetWidth; // This forces the browser to restart the CSS animation
            popupEl.classList.add('animate-popup');
        }

        // Start Game
        createBoard();
        refillReserve();

    </script>
</body>
</html>
