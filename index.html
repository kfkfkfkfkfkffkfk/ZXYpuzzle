<!DOCTYPE html>
<html>
<head>
    <title>ZXYpuzzle - Ultimate Smart Edition</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        @keyframes rainbowSwirl { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        @keyframes jellyBounce { 0%, 100% { transform: scale(1); } 25% { transform: scale(1.05) translateY(-5px); } 50% { transform: scale(0.95) translateY(5px); } 75% { transform: scale(1.02) translateY(-2px); } }
        @keyframes bounceUpAndFade { 0% { transform: translateY(0) scale(0.2); opacity: 1; } 40% { transform: translateY(-50px) scale(1.3); opacity: 1; } 70% { transform: translateY(-40px) scale(1.1); opacity: 1; } 100% { transform: translateY(-80px) scale(1); opacity: 0; } }
        @keyframes glowPulse { from { background: rgba(255, 255, 255, 0.5); box-shadow: 0 0 10px rgba(255,255,255,0.3); } to { background: rgba(255, 255, 255, 0.95); box-shadow: 0 0 20px rgba(255,255,255,0.8); } }
        @keyframes pulseRed { from { transform: scale(1); text-shadow: 0 0 10px #FF0055; } to { transform: scale(1.1); text-shadow: 0 0 20px #FF0055, 0 0 30px #FF0055; } }

        body { 
            font-family: 'Segoe UI', Roboto, Helvetica, sans-serif; 
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            background: linear-gradient(45deg, #FF0055, #00DDFF, #FFEA00, #00FF66, #BD00FF);
            background-size: 400% 400%; animation: rainbowSwirl 15s ease infinite;
            color: #333; margin: 0; 
            height: 100dvh; 
            width: 100vw; overflow: hidden; 
            touch-action: none; /* Stops iOS gestures */
            user-select: none; -webkit-user-select: none;
        }

        /* UI SCREENS */
        #start-screen, #end-screen {
            position: fixed; inset: 0; z-index: 99999;
            background: rgba(10, 15, 30, 0.95); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #fff; text-align: center; padding: 20px; box-sizing: border-box;
        }
        #end-screen { display: none; background: rgba(255,255,255,0.9); color: #333; z-index: 100000; }
        
        #start-screen h1 { font-size: 48px; font-weight: 900; letter-spacing: 4px; margin-bottom: 10px; background: linear-gradient(to right, #00DDFF, #00FF66); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        #start-screen p.subtitle { font-size: 18px; color: #aaa; margin-bottom: 40px; }
        
        .mode-btn { background: rgba(255, 255, 255, 0.05); border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 16px; padding: 25px; margin: 10px; width: 100%; max-width: 350px; cursor: pointer; transition: all 0.2s ease; text-align: left; }
        .mode-btn:hover { background: rgba(255, 255, 255, 0.15); border-color: #00DDFF; transform: translateY(-3px); }
        .mode-btn.rush:hover { border-color: #FF0055; }
        .mode-btn h2 { margin: 0 0 5px 0; font-size: 24px; color: #fff; }
        .mode-btn p { margin: 0; font-size: 14px; color: #bbb; }
        
        .action-btn { background: #fff; color: #FF0055; border: 3px solid #FF0055; padding: 18px 24px; border-radius: 30px; font-weight: 900; cursor: pointer; margin: 10px; width: 100%; max-width: 280px; font-size: 16px; box-shadow: 0 8px 20px rgba(0,0,0,0.1); transition: all 0.15s; }
        .action-btn:active { transform: scale(0.9); }

        /* GAME BOARD WRAPPER */
        #game-board { 
            position: relative; width: 100vw; height: 100dvh;
            display: none; flex-direction: column; align-items: center; justify-content: flex-start; z-index: 1; 
        }
        .shake { animation: jellyBounce 0.4s cubic-bezier(.25, 1.5, .5, 1) both; }

        #timer-container { width: 600px; max-width: 90vw; display: none; flex-direction: column; align-items: center; margin-top: 10px; }
        #timer-display { font-size: 24px; font-weight: 900; color: #fff; text-shadow: 0 2px 10px rgba(0,0,0,0.5); }
        #timer-bar-bg { width: 100%; height: 10px; background: rgba(0,0,0,0.6); border-radius: 6px; overflow: hidden; border: 2px solid rgba(255,255,255,0.3); }
        #timer-bar-fill { width: 100%; height: 100%; background: #00FF66; }
        
        #score-display { font-size: 36px; font-weight: 900; margin: 5px 0; color: #fff; text-shadow: 2px 2px 0px rgba(0,0,0,0.1), 0 10px 20px rgba(0,0,0,0.2); }
        
        /* DEFAULT DESKTOP / LARGE SCREEN */
        #play-area {
            display: flex; flex-direction: row; align-items: stretch; justify-content: space-between; gap: 3vw;
            width: 100%; flex: 1; min-height: 0; padding: 0 3vw 3vw 3vw; box-sizing: border-box;
        }

        #play-grid { 
            display: flex; flex-wrap: wrap; align-content: flex-start;
            width: 600px; height: 600px; max-width: 55vw; max-height: 55vw;
            background: rgba(0, 0, 0, 0.45); padding: 12px; border-radius: 24px; box-sizing: border-box; 
            justify-content: center; border: 2px solid rgba(255, 255, 255, 0.15); backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px); box-shadow: 0 20px 50px rgba(0,0,0,0.4); flex-shrink: 0;
            margin: auto 0;
        }
        
        .block-cell { 
            width: calc(10% - 2px); height: calc(10% - 2px); margin: 1px; background: rgba(0, 0, 0, 0.35); 
            border-radius: 8px; pointer-events: none; box-sizing: border-box; transition: all 0.15s ease; border: 1px solid rgba(255, 255, 255, 0.05); 
        }
        .block-cell.active { border: none; z-index: 2; position: relative; }
        .block-cell.snap-hint { animation: glowPulse 0.4s infinite alternate; border-radius: 6px; border: 2px solid #fff; transform: scale(1.05); z-index: 10; }

        /* DOCKS */
        .side-dock-wrapper {
            flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            background: rgba(0,0,0,0.3); box-shadow: inset 0 10px 30px rgba(0,0,0,0.5), 0 10px 20px rgba(0,0,0,0.2);
            border-radius: 24px; padding: 20px; box-sizing: border-box; border: 1px solid rgba(255,255,255,0.05); overflow-y: auto;
        }

        .dock-title { color: rgba(255,255,255,0.4); font-size: 16px; font-weight: 900; letter-spacing: 4px; margin-bottom: 20px; text-align: center; width: 100%; border-bottom: 2px dashed rgba(255,255,255,0.1); padding-bottom: 10px; }
        
        #reward-dock { display: none; flex-direction: column; align-items: center; gap: 15px; width: 100%; background: rgba(255, 215, 0, 0.15); border: 2px dashed rgba(255, 215, 0, 0.8); padding: 15px; border-radius: 16px; box-sizing: border-box; }
        #dock { display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%; }
        
        .shape-wrapper { position: relative; cursor: grab; padding: 10px; touch-action: none; transition: transform 0.2s, filter 0.3s, opacity 0.3s; }
        .shape-wrapper:active { transform: scale(1.15); }
        .shape-layout { display: flex; flex-direction: column; align-items: center; pointer-events: none; }
        .shape-row { display: flex; }
        
        .shape-dot { width: 28px; height: 28px; margin: 1px; border-radius: 6px; border: 1px solid transparent; flex-shrink: 0; }
        .shape-dot.filled { border: 1px solid rgba(255,255,255,0.8); box-shadow: inset 2px 2px 5px rgba(255,255,255,0.8), 0 4px 8px rgba(0,0,0,0.2); pointer-events: auto; }
        
        .reward-mini .shape-dot { width: 16px; height: 16px; margin: 1px; border-radius: 4px; }
        .reward-badge { position: absolute; bottom: 0; right: 0; background: #FF0055; color: #fff; border: 2px solid #fff; border-radius: 50%; width: 24px; height: 24px; font-size: 13px; font-weight: 900; display: flex; align-items: center; justify-content: center; z-index: 10; box-shadow: 0 2px 5px rgba(0,0,0,0.4); pointer-events: none; }

        .floating { position: fixed; pointer-events: none; z-index: 9999; transform: scale(1.5); filter: drop-shadow(0 25px 20px rgba(0,0,0,0.4)); opacity: 0.95; transform-origin: top left; }
        .floating-score { position: fixed; z-index: 10000; pointer-events: none; font-size: 36px; font-weight: 900; color: #fff; text-align: center; -webkit-text-stroke: 1px rgba(0,0,0,0.1); animation: bounceUpAndFade 1.2s forwards; }

        /* --- RESPONSIVE LAYOUTS --- */
        
        /* PORTRAIT MODE (iPhone/iPad Upright) */
        @media (orientation: portrait) and (max-width: 1024px) {
            #score-display { font-size: 28px; }
            #play-area { flex-direction: column; align-items: center; justify-content: flex-start; gap: 10px; padding: 5px; }
            #play-grid { order: 1; width: 96vw; height: 96vw; max-width: 600px; max-height: 600px; padding: 6px; border-radius: 16px; }
            .side-dock-wrapper { order: 2; flex: none; width: 96vw; max-width: 600px; min-height: auto; padding: 10px; flex-direction: column; }
            .dock-title { margin-bottom: 10px; padding-bottom: 5px; font-size: 14px; }
            #dock { flex-direction: row; flex-wrap: wrap; justify-content: center; gap: 8px; }
            #reward-dock { flex-direction: row; flex-wrap: wrap; justify-content: center; gap: 8px; padding: 10px; }
            .shape-dot { width: min(6.5vw, 32px); height: min(6.5vw, 32px); }
            .shape-wrapper { padding: 5px; }
        }

        /* LANDSCAPE MODE (iPhone/iPad Sideways) */
        @media (orientation: landscape) and (max-height: 800px) {
            #score-display { font-size: 24px; position: absolute; top: 10px; left: 20px; z-index: 10;}
            #timer-container { position: absolute; top: 10px; right: 20px; width: 150px; z-index: 10;}
            #play-area { flex-direction: row; align-items: center; justify-content: center; gap: 2vw; padding: 10px; height: 100%; }
            #play-grid { width: 85vh; height: 85vh; max-width: 600px; max-height: 600px; padding: 8px; margin: 0; }
            .side-dock-wrapper { flex: 1; max-width: 250px; height: 85vh; padding: 10px; justify-content: flex-start; }
            .shape-dot { width: min(3vh, 24px); height: min(3vh, 24px); }
        }
    </style>
</head>
<body>

<div id="start-screen">
    <h1>ZXYpuzzle</h1>
    <p class="subtitle">Ultimate Smart Edition</p>
    <div class="mode-btn classic" onclick="startGame('classic')">
        <h2>CLASSIC MODE</h2><p>Take your time. Build massive combos.</p>
    </div>
    <div class="mode-btn rush" onclick="startGame('rush')">
        <h2>RUSH MODE</h2><p>10 seconds per move. Act fast!</p>
    </div>
</div>

<div id="game-board">
    <div id="timer-container"><div id="timer-display">10.0s</div><div id="timer-bar-bg"><div id="timer-bar-fill"></div></div></div>
    <div id="score-display">0</div>
    
    <div id="play-area">
        <div class="side-dock-wrapper reserve-area">
            <div class="dock-title">RESERVE STASH</div>
            <div id="reward-dock"></div>
        </div>
        
        <div id="play-grid"></div>
        
        <div class="side-dock-wrapper active-area">
            <div class="dock-title">ACTIVE PIECES</div>
            <div id="dock"></div>
        </div>
    </div>
</div>

<div id="end-screen">
    <h1 style="color:#FF0055; font-size: 50px; margin-bottom: 5px;">OH NO!</h1>
    <p id="death-reason" style="color:#FF8800; font-weight:bold; font-size: 18px; margin: 0;"></p>
    <p style="margin-top: 10px; font-size: 20px; font-weight: bold;">SCORE: <br><span id="final-tally" style="color: #BD00FF; font-size: 42px;">0</span></p>
    <button id="btn-continue" class="action-btn" onclick="useContinue()" style="background:#00FF66; color:#333; border-color:#00FF66;">CONTINUE</button>
    <button class="action-btn" onclick="startGame(currentMode)" style="background:#FFEA00; color:#333; border-color:#FFEA00;">START OVER</button>
</div>

<script>
    // STOP iOS PULL-TO-REFRESH GLOBALLY
    document.addEventListener('touchmove', function(e) {
        if (e.target.closest('body')) { e.preventDefault(); }
    }, { passive: false });

    const playGrid = document.getElementById("play-grid");
    const dockEl = document.getElementById("dock");
    const rewardDockEl = document.getElementById("reward-dock");
    const scoreText = document.getElementById("score-display");
    const timerContainer = document.getElementById("timer-container");
    const timerDisplay = document.getElementById("timer-display");
    const timerBarFill = document.getElementById("timer-bar-fill");
    const gameBoard = document.getElementById("game-board");
    
    // --- AUDIO SYSTEM ---
    // Make sure you upload a file named "snap.mp3" to your github repository!
    const snapSound = new Audio('snap.mp3'); 

    let boardState = Array(100).fill(null);
    let currentScore = 0;
    let activeShapes = []; 
    let activePopups = 0; 
    let continuesLeft = 3; 
    let currentMode = 'classic';
    let rushTimer; let timeRemaining = 10.0; let gameActive = false; let lastTime = 0;

    const candyColors = ["#FF0055", "#FF8800", "#FFEA00", "#00FF66", "#00DDFF", "#BD00FF", "#FF00AA"];
    
    for (let i = 0; i < 100; i++) {
        const cell = document.createElement("div"); cell.className = "block-cell"; playGrid.appendChild(cell);
    }

    const layouts = [
        [[0,0]], [[0,0], [0,1]], [[0,0], [1,0]], 
        [[0,0], [0,1], [1,0], [1,1]], [[0,0], [0,1], [0,2], [0,3]], 
        [[0,0], [1,0], [2,0], [3,0]], [[0,0], [0,1], [0,2], [1,1]], 
        [[0,0], [1,0], [2,0], [2,1]], [[0,1], [1,1], [2,0], [2,1]], 
        [[0,0], [0,1], [0,2], [1,0], [1,1], [1,2], [2,0], [2,1], [2,2]], 
        [[0,0], [1,1], [2,2]], [[0,0], [0,1], [0,2]]
    ];

    window.startGame = function(mode) {
        currentMode = mode; continuesLeft = 3; 
        document.getElementById("start-screen").style.display = "none";
        document.getElementById("end-screen").style.display = "none";
        document.getElementById("game-board").style.display = "flex";
        timerContainer.style.display = currentMode === 'rush' ? "flex" : "none";
        wipeBoardClean();
    };

    function gameLoop(timestamp) {
        if (!gameActive || currentMode !== 'rush') return;
        if (!lastTime) lastTime = timestamp;
        timeRemaining -= (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        if (timeRemaining <= 0) { timeRemaining = 0; triggerGameOver("OUT OF TIME! â°"); }
        else {
            timerDisplay.innerText = timeRemaining.toFixed(1) + "s";
            timerBarFill.style.width = (timeRemaining * 10) + "%";
            rushTimer = requestAnimationFrame(gameLoop);
        }
    }

    function spawnFloatingText(text, targetEl, isSpecial = false) {
        const popup = document.createElement("div");
        popup.className = "floating-score"; popup.innerHTML = text; 
        popup.style.color = isSpecial ? "#FFEA00" : candyColors[Math.floor(Math.random() * candyColors.length)];
        const rect = targetEl.getBoundingClientRect();
        popup.style.left = (rect.left + rect.width / 2 - 40) + "px";
        popup.style.top = (rect.top + rect.height / 2 - (activePopups * 35)) + "px";
        document.body.appendChild(popup);
        activePopups++; setTimeout(() => activePopups--, 1200); setTimeout(() => popup.remove(), 1200);
    }

    function fillDock() {
        dockEl.innerHTML = "";
        activeShapes = activeShapes.filter(s => s !== null && s.isReward && s.count > 0); 
        let newShapesToAdd = [];
        for (let i = 0; i < 3; i++) {
            let layout = layouts[Math.floor(Math.random() * layouts.length)];
            const shapeObj = {layout: layout, color: candyColors[Math.floor(Math.random()*candyColors.length)], element: null, isReward: false, count: 1};
            newShapesToAdd.push(shapeObj);
        }
        newShapesToAdd.forEach(shapeObj => { activeShapes.push(shapeObj); buildDraggableShape(shapeObj, dockEl); });
        verifyMovesLeft();
    }

    function findSmartestSpot(shapeObj) {
        let bestSpot = null; let maxScore = -Infinity;
        const validSpots = findAllValidSpots(shapeObj.layout);
        for (let spot of validSpots) {
            let score = 0;
            shapeObj.layout.forEach(pt => { boardState[(spot.r+pt[0])*10 + (spot.c+pt[1])] = 'temp'; });
            let lines = 0;
            for(let r=0; r<10; r++) if ([...Array(10)].every((_,c) => boardState[r*10+c])) lines++;
            score += lines * 1000;
            shapeObj.layout.forEach(pt => { boardState[(spot.r+pt[0])*10 + (spot.c+pt[1])] = null; });
            if (score > maxScore) { maxScore = score; bestSpot = spot; }
        }
        return bestSpot;
    }

    function consumeShapeAndCheckState(shapeObj, wrap) {
        let idx = activeShapes.indexOf(shapeObj); if (idx > -1) activeShapes[idx] = null; wrap.remove();
        if (!activeShapes.some(s => s && !s.isReward)) fillDock(); else verifyMovesLeft();
        if (currentMode === 'rush') { timeRemaining = 10.0; }
    }

    function getBestDropPos(shapeObj, clientX, clientY, isDrop) {
        const hoverPos = locateGridIndex(clientX, clientY);
        if (hoverPos !== null) {
            const r = Math.floor(hoverPos/10) - shapeObj.dragOffsetR;
            const c = (hoverPos%10) - shapeObj.dragOffsetC;
            if (hasRoom(shapeObj.layout, r, c)) return {r, c};
        }
        return null;
    }

    function buildDraggableShape(shapeObj, containerEl) {
        const wrap = document.createElement("div"); wrap.className = "shape-wrapper";
        shapeObj.element = wrap;
        
        const gridBox = document.createElement("div"); gridBox.className = "shape-layout";
        let rMax = Math.max(...shapeObj.layout.map(p=>p[0])), cMax = Math.max(...shapeObj.layout.map(p=>p[1]));

        for (let r=0; r<=rMax; r++) {
            const rDiv = document.createElement("div"); rDiv.className = "shape-row";
            for (let c=0; c<=cMax; c++) {
                const dot = document.createElement("div");
                let isOn = shapeObj.layout.some(pt => pt[0]===r && pt[1]===c);
                dot.className = isOn ? "shape-dot filled" : "shape-dot blank";
                if(isOn) { dot.style.background = shapeObj.color; dot.dataset.r = r; dot.dataset.c = c; }
                rDiv.appendChild(dot);
            }
            gridBox.appendChild(rDiv);
        }
        wrap.appendChild(gridBox);
        containerEl.appendChild(wrap);

        wrap.onpointerdown = (e) => {
            if (!gameActive) return;
            e.preventDefault(); 
            let startX = e.clientX; let startY = e.clientY; let startTime = Date.now(); let isSwipingDown = false;
            let grabR = shapeObj.layout[0][0], grabC = shapeObj.layout[0][1];
            if (e.target.classList.contains('filled')) { grabR = parseInt(e.target.dataset.r); grabC = parseInt(e.target.dataset.c); }
            shapeObj.dragOffsetR = grabR; shapeObj.dragOffsetC = grabC; 

            const ghost = wrap.cloneNode(true); ghost.classList.add("floating"); document.body.appendChild(ghost); wrap.style.opacity = "0.05";
            
            const dotSize = window.innerWidth <= 768 ? Math.min(window.innerWidth * 0.065, 32) : 28; 
            const scale = 1.5;
            const originX = (10 + grabC * dotSize + dotSize/2) * scale;
            const originY = (10 + grabR * dotSize + dotSize/2) * scale;

            const move = (ev) => {
                let dx = ev.clientX - startX; let dy = ev.clientY - startY;

                // Smart swipe detection
                if (!isSwipingDown && dy > 30 && Math.abs(dx) < 20 && (Date.now() - startTime) < 400) {
                    isSwipingDown = true;
                    window.removeEventListener("pointermove", move); window.removeEventListener("pointerup", drop);
                    let bestSpot = findSmartestSpot(shapeObj);
                    if (bestSpot) { lockInShape(shapeObj, bestSpot.r, bestSpot.c); consumeShapeAndCheckState(shapeObj, wrap); } 
                    else { wrap.style.opacity = "1"; }
                    wipeHints(); ghost.remove(); return;
                }

                // --- DRAG CLAMPING LOGIC ---
                let newX = ev.clientX - originX;
                let newY = ev.clientY - originY;
                
                // Keep the ghost piece inside the browser window
                newX = Math.max(0, Math.min(newX, window.innerWidth - ghost.offsetWidth));
                newY = Math.max(0, Math.min(newY, window.innerHeight - ghost.offsetHeight));

                ghost.style.left = newX + "px"; ghost.style.top = newY + "px"; 
                wipeHints();
                const targetPos = getBestDropPos(shapeObj, ev.clientX, ev.clientY, false);
                if (targetPos) drawHint(shapeObj.layout, targetPos.r, targetPos.c);
            };

            const drop = (ev) => {
                window.removeEventListener("pointermove", move); window.removeEventListener("pointerup", drop);
                const targetPos = getBestDropPos(shapeObj, ev.clientX, ev.clientY, true);
                if (targetPos) { lockInShape(shapeObj, targetPos.r, targetPos.c); consumeShapeAndCheckState(shapeObj, wrap); } 
                else { wrap.style.opacity = "1"; }
                wipeHints(); ghost.remove(); verifyMovesLeft(); 
            };
            window.addEventListener("pointermove", move); window.addEventListener("pointerup", drop);
        };
    }

    function locateGridIndex(x, y) {
        const tiles = playGrid.children;
        for (let i = 0; i < 100; i++) {
            const b = tiles[i].getBoundingClientRect();
            if (x >= b.left && x <= b.right && y >= b.top && y <= b.bottom) return i;
        }
        return null;
    }

    function findAllValidSpots(layout) {
        let spots = [];
        for (let r=0; r<10; r++) for (let c=0; c<10; c++) if (hasRoom(layout, r, c)) spots.push({r, c});
        return spots;
    }

    function hasRoom(layout, startR, startC) {
        return layout.every(pt => { let r = startR+pt[0], c = startC+pt[1]; return r>=0 && r<10 && c>=0 && c<10 && boardState[r*10+c] === null; });
    }

    function lockInShape(shapeObj, startR, startC) {
        // --- PLAY SOUND AND HAPTICS ---
        snapSound.currentTime = 0; 
        snapSound.play().catch(e => console.log("User must interact with page before audio plays."));
        if (navigator.vibrate) { navigator.vibrate(50); } // Haptic feedback (Works on Android)

        shapeObj.layout.forEach(pt => {
            let i = (startR+pt[0])*10 + (startC+pt[1]);
            boardState[i] = shapeObj.color; 
            playGrid.children[i].classList.add("active");
            playGrid.children[i].style.background = shapeObj.color;
            playGrid.children[i].style.boxShadow = `inset 2px 2px 8px rgba(255,255,255,0.7), inset -2px -2px 8px rgba(0,0,0,0.1), 0 2px 5px rgba(0,0,0,0.1)`;
        });
        currentScore += shapeObj.layout.length * 10; scoreText.innerText = currentScore;
        checkClears();
    }

    function checkClears() {
        let fullRows = [], fullCols = [];
        for(let r=0; r<10; r++) { if ([...Array(10)].every((_,c) => boardState[r*10+c])) fullRows.push(r); }
        for(let c=0; c<10; c++) { if ([...Array(10)].every((_,r) => boardState[r*10+c])) fullCols.push(c); }

        const totalLines = fullRows.length + fullCols.length;
        if (totalLines > 0) {
            gameBoard.classList.remove("shake"); void gameBoard.offsetWidth; gameBoard.classList.add("shake");
            let pts = totalLines * 1000; currentScore += pts; scoreText.innerText = currentScore;
            spawnFloatingText("+" + pts, playGrid);

            let toClear = new Set();
            fullRows.forEach(r => { for(let c=0; c<10; c++) toClear.add(r*10+c); });
            fullCols.forEach(c => { for(let r=0; r<10; r++) toClear.add(r*10+c); });

            toClear.forEach(idx => {
                boardState[idx] = null; playGrid.children[idx].classList.remove("active");
                playGrid.children[idx].style.background = "rgba(0, 0, 0, 0.35)"; playGrid.children[idx].style.boxShadow = "inset 0 2px 5px rgba(0,0,0,0.6)";
            });
        }
    }

    function verifyMovesLeft() {
        let canPlay = activeShapes.some(s => s && findAllValidSpots(s.layout).length > 0);
        activeShapes.forEach(s => { if(s) s.element.style.opacity = findAllValidSpots(s.layout).length > 0 ? "1" : "0.3"; });
        if (!canPlay && activeShapes.some(s=>s)) triggerGameOver("NO MOVES LEFT! ðŸ’€");
    }

    function triggerGameOver(reasonText) {
        gameActive = false; cancelAnimationFrame(rushTimer);
        document.getElementById("death-reason").innerText = reasonText;
        document.getElementById("final-tally").innerText = currentScore;
        const btn = document.getElementById("btn-continue");
        if(continuesLeft > 0) { btn.style.display = "inline-block"; } else btn.style.display = "none";
        setTimeout(() => document.getElementById("end-screen").style.display = "flex", 800);
    }

    window.useContinue = function() {
        if (continuesLeft > 0) {
            continuesLeft--; document.getElementById("end-screen").style.display = "none";
            fillDock(); gameActive = true; 
            if (currentMode === 'rush') { timeRemaining = 10.0; lastTime = 0; rushTimer = requestAnimationFrame(gameLoop); }
        }
    };

    function wipeBoardClean() {
        boardState.fill(null); currentScore = 0; scoreText.innerText = currentScore;
        Array.from(playGrid.children).forEach(c => { c.classList.remove("active"); c.style.background = "rgba(0,0,0,0.35)"; c.style.boxShadow = "inset 0 2px 5px rgba(0,0,0,0.6)"; });
        activeShapes = []; fillDock(); gameActive = true; 
        if (currentMode === 'rush') { timeRemaining = 10.0; lastTime = 0; rushTimer = requestAnimationFrame(gameLoop); }
    }

    function drawHint(layout, startR, startC) {
        layout.forEach(pt => { let r=startR+pt[0], c=startC+pt[1]; if(r>=0&&r<10&&c>=0&&c<10) playGrid.children[r*10+c].classList.add("snap-hint"); });
    }
    function wipeHints() { for (let t of playGrid.children) t.classList.remove("snap-hint"); }
</script>
</body>
</html>
